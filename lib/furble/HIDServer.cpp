#include <NimBLEDevice.h>

#include "FurbleTypes.h"
#include "HIDServer.h"

#define HID_GENERIC_REMOTE (0x180)

// AUTO-GENERATED by WaratahCmd.exe (https://github.com/microsoft/hidtools)
static const uint8_t hidReportDescriptor[] = {
    0x05,
    0x0C,  // UsagePage(Consumer[0x000C])
    0x09,
    0x01,  // UsageId(Consumer Control[0x0001])
    0xA1,
    0x01,  // Collection(Application)
    0x85,
    0x01,  //     ReportId(1)
    0x09,
    0xE9,  //     UsageId(Volume Increment[0x00E9])
    0x15,
    0x00,  //     LogicalMinimum(0)
    0x25,
    0x01,  //     LogicalMaximum(1)
    0x95,
    0x01,  //     ReportCount(1)
    0x75,
    0x01,  //     ReportSize(1)
    0x81,
    0x02,  //     Input(Data, Variable, Absolute, NoWrap, Linear, PreferredState, NoNullPosition,
           //     BitField)
    0xC0,  // EndCollection()
};

namespace Furble {

HIDServer *HIDServer::hidServer = nullptr;

HIDServer::HIDServer() {
  // configure advertising as a BLE server
  m_Server = NimBLEDevice::createServer();
  m_Server->setCallbacks(this);
  m_Server->advertiseOnDisconnect(false);

  m_HID = new NimBLEHIDDevice(m_Server);
  m_Input = m_HID->getInputReport(1);

  // set manufacturer name
  m_HID->setManufacturer("Maker Community");
  // set USB vendor and product ID
  m_HID->setPnp(0x02, 0xe502, 0xa111, 0x0210);
  // information about HID device: device is not localized, device can be connected
  m_HID->setHidInfo(0x00, 0x02);

  m_HID->setReportMap((uint8_t *)hidReportDescriptor, sizeof(hidReportDescriptor));

  // advertise the services
  m_Advertising = m_Server->getAdvertising();
  m_Advertising->setName(FURBLE_STR);
  m_Advertising->setAppearance(HID_GENERIC_REMOTE);
  m_Advertising->addServiceUUID(m_HID->getHidService()->getUUID());
  m_Advertising->enableScanResponse(true);
}

HIDServer::~HIDServer() {
  m_hidCallbacks = nullptr;
}

HIDServer *HIDServer::getInstance(void) {
  if (hidServer == nullptr) {
    hidServer = new HIDServer();
  }

  return hidServer;
}

void HIDServer::start(NimBLEAddress *address, HIDServerCallbacks *hidCallback) {
  m_hidCallbacks = hidCallback;
  m_HID->startServices();

#if 0
  // Cannot get directed advertising working properly.
  if (address != nullptr) {
    m_Advertising->setConnectableMode(BLE_GAP_CONN_MODE_DIR);
  }
#endif
  m_Advertising->start(0, address);
}

void HIDServer::stop(void) {
  m_Advertising->stop();
  m_Server->stopAdvertising();
}

void HIDServer::onConnect(NimBLEServer *p_Server, NimBLEConnInfo &connInfo) {
  // NimBLEDevice::startSecurity(connInfo.getConnHandle());
}

void HIDServer::onAuthenticationComplete(NimBLEConnInfo &connInfo) {
  // do nothing
}

void HIDServer::onIdentity(NimBLEConnInfo &connInfo) {
  auto address = connInfo.getIdAddress();
#if 0
  // Moved to _connect() call in MobileDevice
  auto peer = NimBLEDevice::getServer()->getClient(connInfo);
  // getValue() hangs, likely due to being called within the callback
  auto name = peer->getValue(NimBLEUUID((uint16_t)BLE_SVC_GAP_UUID16), NimBLEUUID((uint16_t)BLE_SVC_GAP_CHR_UUID16_DEVICE_NAME));
  ESP_LOGI("HID", "peer = %s", name.c_str());
#endif
  if (m_hidCallbacks != nullptr) {
    m_hidCallbacks->onComplete(address, (std::string)address);
  }
}

NimBLECharacteristic *HIDServer::getInput(void) {
  return m_Input;
}

NimBLEConnInfo HIDServer::getConnInfo(NimBLEAddress &address) {
  return m_Server->getPeerInfo(address);
}

void HIDServer::disconnect(NimBLEAddress &address) {
  NimBLEConnInfo info = m_Server->getPeerInfo(address);
  m_Server->disconnect(info);
}

bool HIDServer::isConnected(const NimBLEAddress &address) {
  NimBLEConnInfo info = m_Server->getPeerInfo(address);

  return (!info.getIdAddress().isNull());
}
}  // namespace Furble
